{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Blaze Blaze is an embeddable dynamic programming language. Download the latest build from GitHub and extract the zip archive. You may add Blaze to your PATH environment variable if you wish. To confirm that Blaze is installed properly, open a command prompt and try running the compiler blzc or the interpreter blzi : > blzc Usage: blzc.exe [options] Options: -s [file] Blaze source file to compile -m [name] Use a custom module name -d Compiles as a debug module -c Print the contents of a module file (source file must be blzm) > blzi Usage: blzi.exe [options] Options: -m [file] Module file to execute -d Print the contents of the module file","title":"Installation"},{"location":"#blaze","text":"Blaze is an embeddable dynamic programming language. Download the latest build from GitHub and extract the zip archive. You may add Blaze to your PATH environment variable if you wish. To confirm that Blaze is installed properly, open a command prompt and try running the compiler blzc or the interpreter blzi : > blzc Usage: blzc.exe [options] Options: -s [file] Blaze source file to compile -m [name] Use a custom module name -d Compiles as a debug module -c Print the contents of a module file (source file must be blzm) > blzi Usage: blzi.exe [options] Options: -m [file] Module file to execute -d Print the contents of the module file","title":"Blaze"},{"location":"start/classes/","text":"Classes Classes are declared using the class keyword. class Counter { var current; Counter(initial) { if(initial == null) current = 0; else current = initial; } func next() { return current++; } } Classes are also first-class values, meaning they can be assigned to variables, passed as arguments, or returned from functions. Note Inside class functions, you can use this to refer to the current instance and access its members, e.g., this.current . Instantiating To create an instance of a class, use the new keyword: func main() { var c1 = new Counter(5); var c2 = new Counter(); console.print(c1.next()); console.print(c1.next()); console.print(c2.next()); console.print(c2.next()); } Class Scope and Visibility Unlike functions and variables, all classes are module-level declarations. They can only be declared at the top scope of a Blaze source file. The following modifiers can be used with classes: public : Exposes the class to other modules private : The class is accessible only within its own module If no modifier is provided, private is assumed. Note All class members (variables and functions) are implicitly public. Blaze does not currently support member-level access modifiers.","title":"Classes"},{"location":"start/classes/#classes","text":"Classes are declared using the class keyword. class Counter { var current; Counter(initial) { if(initial == null) current = 0; else current = initial; } func next() { return current++; } } Classes are also first-class values, meaning they can be assigned to variables, passed as arguments, or returned from functions. Note Inside class functions, you can use this to refer to the current instance and access its members, e.g., this.current .","title":"Classes"},{"location":"start/classes/#instantiating","text":"To create an instance of a class, use the new keyword: func main() { var c1 = new Counter(5); var c2 = new Counter(); console.print(c1.next()); console.print(c1.next()); console.print(c2.next()); console.print(c2.next()); }","title":"Instantiating"},{"location":"start/classes/#class-scope-and-visibility","text":"Unlike functions and variables, all classes are module-level declarations. They can only be declared at the top scope of a Blaze source file. The following modifiers can be used with classes: public : Exposes the class to other modules private : The class is accessible only within its own module If no modifier is provided, private is assumed. Note All class members (variables and functions) are implicitly public. Blaze does not currently support member-level access modifiers.","title":"Class Scope and Visibility"},{"location":"start/events/","text":"Events Events are objects that allow you to attach callback functions, which are triggered when the event is invoked. Creating events Events are created using the keyword event as an expression. You can invoke an event simply by calling it like a function: export message = event; func main() { message(\"Hello World\"); } Handling events To handle an event, you can define a callback using the event keyword again, this time as a declaration. import console; import message; event message(msg) { console.print(\"Received: \", msg); } When the event message is triggered (as shown in the previous example), all callbacks registered for it will be executed with the given arguments. Filtering Parameters You can restrict when a callback is executed by specifying expected values for the parameters. This allows you to respond only to specific cases. import console; import message; event message(msg [\"hello\", \"world\"]) { console.print(\"Received special case: \", msg); } In the example above, the callback is triggered only when msg is \"hello\" or \"world\" .","title":"Events"},{"location":"start/events/#events","text":"Events are objects that allow you to attach callback functions, which are triggered when the event is invoked.","title":"Events"},{"location":"start/events/#creating-events","text":"Events are created using the keyword event as an expression. You can invoke an event simply by calling it like a function: export message = event; func main() { message(\"Hello World\"); }","title":"Creating events"},{"location":"start/events/#handling-events","text":"To handle an event, you can define a callback using the event keyword again, this time as a declaration. import console; import message; event message(msg) { console.print(\"Received: \", msg); } When the event message is triggered (as shown in the previous example), all callbacks registered for it will be executed with the given arguments.","title":"Handling events"},{"location":"start/events/#filtering-parameters","text":"You can restrict when a callback is executed by specifying expected values for the parameters. This allows you to respond only to specific cases. import console; import message; event message(msg [\"hello\", \"world\"]) { console.print(\"Received special case: \", msg); } In the example above, the callback is triggered only when msg is \"hello\" or \"world\" .","title":"Filtering Parameters"},{"location":"start/functions/","text":"Functions As we've seen in the previous sections, functions are declared using the func keyword. func my_func(arg1, arg2) { // code } Functions are first-class values in Blaze, meaning they can be assigned to variables, passed as arguments, or returned from other functions. You can also define functions as expressions (lambdas), for example: import console; func main() { var my_func = func(arg1, arg2) { console.print(\"Called with: \", arg1, \" \", arg2); }; my_func(20, \"aaa\"); } Module Functions Module-level functions are declared at the top scope of a Blaze source file. Like module variables, functions can be exposed and requested from other modules. The following modifiers can be used with module functions: public : Exposes the function to other modules private : The function is accessible only within its own module If no modifier is provided, private is assumed by default. Here's an example of a module that exposes two functions: var count = 0; public func next() { return count++; } public func current() { return count; } In another module, the exposed functions can be accessed as follows: import console; import next; import current; func main() { console.print(current()); next(); next(); console.print(current()); } Initialization Internally, module-level functions are treated as function objects stored in module variables. That means the following declaration: public func my_func() { // code } Is internally equivalent to: public var my_func; static my_func = func() { // code }; This ensures consistency with how module variables are initialized and makes the language easier to reason about.","title":"Functions"},{"location":"start/functions/#functions","text":"As we've seen in the previous sections, functions are declared using the func keyword. func my_func(arg1, arg2) { // code } Functions are first-class values in Blaze, meaning they can be assigned to variables, passed as arguments, or returned from other functions. You can also define functions as expressions (lambdas), for example: import console; func main() { var my_func = func(arg1, arg2) { console.print(\"Called with: \", arg1, \" \", arg2); }; my_func(20, \"aaa\"); }","title":"Functions"},{"location":"start/functions/#module-functions","text":"Module-level functions are declared at the top scope of a Blaze source file. Like module variables, functions can be exposed and requested from other modules. The following modifiers can be used with module functions: public : Exposes the function to other modules private : The function is accessible only within its own module If no modifier is provided, private is assumed by default. Here's an example of a module that exposes two functions: var count = 0; public func next() { return count++; } public func current() { return count; } In another module, the exposed functions can be accessed as follows: import console; import next; import current; func main() { console.print(current()); next(); next(); console.print(current()); }","title":"Module Functions"},{"location":"start/functions/#initialization","text":"Internally, module-level functions are treated as function objects stored in module variables. That means the following declaration: public func my_func() { // code } Is internally equivalent to: public var my_func; static my_func = func() { // code }; This ensures consistency with how module variables are initialized and makes the language easier to reason about.","title":"Initialization"},{"location":"start/helloworld/","text":"First program in Blaze To write a simple hello world program, create a file (eg. hw.blz ) and write the following code: extern var console; func main() { console.print(\"Hello World\"); } Now we use blzc to compile the source file to a module file: > blzc -s hw.blz Compiled to 'hw.blzm' Now that we have a module file, we can run it using blzi : > blzi -m hw.blzm Hello World This is a simple hello world program. Notice that we have to specify that the console variable is external. Blaze doesn't have a concept of a global environment like most embeddable/scripting languages do. Blaze works with modules. Each Blaze source file is compiled to a module, which contains functions, classes and variables. Variables can be declared as public, private or extern. The console interface is provided from an external library that contains a module. During runtime each module can have multiple children and a parent which make up a hierarchy.","title":"Hello World"},{"location":"start/helloworld/#first-program-in-blaze","text":"To write a simple hello world program, create a file (eg. hw.blz ) and write the following code: extern var console; func main() { console.print(\"Hello World\"); } Now we use blzc to compile the source file to a module file: > blzc -s hw.blz Compiled to 'hw.blzm' Now that we have a module file, we can run it using blzi : > blzi -m hw.blzm Hello World This is a simple hello world program. Notice that we have to specify that the console variable is external. Blaze doesn't have a concept of a global environment like most embeddable/scripting languages do. Blaze works with modules. Each Blaze source file is compiled to a module, which contains functions, classes and variables. Variables can be declared as public, private or extern. The console interface is provided from an external library that contains a module. During runtime each module can have multiple children and a parent which make up a hierarchy.","title":"First program in Blaze"},{"location":"start/variables/","text":"Variables Variables in Blaze are declared using the var keyword: import console; func main() { var name = console.input(\"What's your name? \"); console.print(\"Hello \", name, \"!\"); } Module Variables Module-level variables are declared at the top scope of a Blaze source file. These variables play an important role in Blaze's modular design. Since each Blaze source file is compiled as a module, variables can be: Exposed to other modules Requested from other modules The following modifiers can be used with module variables: public : Exposes the variable to other modules private : The variable is accessible only within its own module extern : Indicates the variable is defined in another module If no modifier is provided, private is assumed by default. var some_var = 20; public var username = \"vladimirdabic\"; extern var console; func main() { console.print(username); } Note public var and extern var can be written in a short way using the export and import aliases, respectively. var some_var = 20; export username = \"vladimirdabic\"; import console; func main() { console.print(username); } Initialization When a module is loaded, all module-level variables are initialized. This is done by what Blaze calls a static function . The static function is a special block of code that runs automatically when the module is loaded, similar to a constructor in a class. It's used to assign initial values or perform setup tasks. You can define static code using the static keyword, which can be followed by either a single statement or a block of statements: static var x = 20; static { // code } For example, the following module variable declaration: var x = 20; Is internally equivalent to: var x; static x = 20; This means module variables are declared first, and then initialized when the module is loaded.","title":"Variables"},{"location":"start/variables/#variables","text":"Variables in Blaze are declared using the var keyword: import console; func main() { var name = console.input(\"What's your name? \"); console.print(\"Hello \", name, \"!\"); }","title":"Variables"},{"location":"start/variables/#module-variables","text":"Module-level variables are declared at the top scope of a Blaze source file. These variables play an important role in Blaze's modular design. Since each Blaze source file is compiled as a module, variables can be: Exposed to other modules Requested from other modules The following modifiers can be used with module variables: public : Exposes the variable to other modules private : The variable is accessible only within its own module extern : Indicates the variable is defined in another module If no modifier is provided, private is assumed by default. var some_var = 20; public var username = \"vladimirdabic\"; extern var console; func main() { console.print(username); } Note public var and extern var can be written in a short way using the export and import aliases, respectively. var some_var = 20; export username = \"vladimirdabic\"; import console; func main() { console.print(username); }","title":"Module Variables"},{"location":"start/variables/#initialization","text":"When a module is loaded, all module-level variables are initialized. This is done by what Blaze calls a static function . The static function is a special block of code that runs automatically when the module is loaded, similar to a constructor in a class. It's used to assign initial values or perform setup tasks. You can define static code using the static keyword, which can be followed by either a single statement or a block of statements: static var x = 20; static { // code } For example, the following module variable declaration: var x = 20; Is internally equivalent to: var x; static x = 20; This means module variables are declared first, and then initialized when the module is loaded.","title":"Initialization"},{"location":"technical/instructions/","text":"Instruction Set A summary of all Blaze instructions is provided in the table below. Note Stack changes are denoted as before \u2192 after , where stack items are shown from bottom to top. Instruction parameters are shown using Greek letters (e.g., \u03b1 is the first parameter, \u03b2 the second, etc). Example of a single-parameter instruction: POP \u03b1 Example of a two-parameter instruction: EXTENDED_ARG \u03b2 LDLOCAL \u03b1 Stack notation example: ..., x, y \u2192 ..., z . This means the instruction pops y and x, and pushes z. Type Name # Params Stack Description 00 NOP 0 \u2192 No operation 01 POP 1 value \u2192 Removes \u03b1 values from the stack 02 EXTENDED_ARG 1 \u2192 Extend the previous argument with N 03 LDNULL 0 \u2192 null Load null instance onto stack 04 LDARG 1 \u2192 value Load function parameter \u03b1 onto stack 05 LDCONST 1 \u2192 value Load constant \u03b1 onto stack 06 LDLOCAL 2 \u2192 value Loads the value from the local slot \u03b1 with upvalue \u03b2 onto the stack 07 LDVAR 1 \u2192 value Load a module variable onto the stack, with \u03b1 representing the string constant which holds the name 08 LDFUNC 1 \u2192 func Loads the function \u03b1 onto the stack 09 LDCLASS 1 \u2192 class Loads the class \u03b1 onto the stack 0A LDBOOL 1 \u2192 value Loads a boolean of value \u03b1 onto the stack 0B STLOCAL 2 value \u2192 Stores the top stack value into local slot \u03b1 with upvalue \u03b2 0C STVAR 1 value \u2192 Stores the top stack value into a module variable, with \u03b1 representing the string constant which holds the name 0D STARG 1 value \u2192 Store top stack value into function parameter \u03b1 0E CALL 1 argn, ..., arg1, callable \u2192 result Calls the top stack value with number of parameters \u03b1 0F RET 0 value \u2192 Returns the top stack value 10 ADD 0 left, right \u2192 result Adds two objects 11 SUB 0 left, right \u2192 result Subtracts two objects 12 MUL 0 left, right \u2192 result Multiplies two objects 13 DIV 0 left, right \u2192 result Divides two objects 14 INTDIV 0 left, right \u2192 result Performs integer division on two objects 15 THROW 0 value \u2192 Throws an exception with top stack value 16 CATCH 1 value \u2192 Stores relative position \u03b1 of the catch block into the exception stack 17 TRY_END 0 \u2192 Indicates the exit of a try block 18 EQ 0 left, right \u2192 result Compares two objects 19 LT 0 left, right \u2192 result Less than comparison 1A LTE 0 left, right \u2192 result Less than or equals comparison 1B NOT 0 value \u2192 negated Negates an object 1C JMP 1 \u2192 Relative jump \u03b1 instructions ahead 1D JMPB 1 \u2192 Relative jump \u03b1 instructions back 1E JMPA 1 \u2192 Absolute jump to instruction \u03b1 1F JMPT 1 value \u2192 Relative jump \u03b1 instructions ahead if top stack value is true 20 JMPF 1 value \u2192 Relative jump \u03b1 instructions ahead if top stack value is false 21 OR 0 left, right \u2192 value Perform a logical OR operation on two objects 22 AND 0 left, right \u2192 value Perform a logical AND operation on two objects 23 DUP 1 value \u2192 value * \u03b1 Create \u03b1 copies of the top stack value 24 VARARGS 1 valuen, ..., value1 \u2192 / 25 LDLIST 1 valuen, ..., value1 \u2192 list Create a list from \u03b1 values from the stack 26 LDOBJ 1 valuen, keyn, ..., value1, key1 \u2192 dict Create a dictionary from \u03b1 key-value pairs from the stack 27 LDINDEX 0 idx, object \u2192 value Load the value stored at index idx from object 28 STINDEX 0 value, idx, object \u2192 Store a value at index idx in object 29 LDPROP 1 object \u2192 value Load object property \u03b1 onto stack, with \u03b1 representing the string constant which holds the name 2A STPROP 1 value, object \u2192 Store value into object property \u03b1, with \u03b1 representing the string constant which holds the name 2B LDEVENT 0 \u2192 event Create and push an event object 2C ITER 0 value \u2192 iterator Create an iterator for an object 2D NEW 1 argn, ... arg1, class \u2192 instance Creates a new instance of a class, with \u03b1 being the number of constructor parameters 2E ATTACH 0 func, event \u2192 Attaches a callback to an event","title":"Instruction Set"},{"location":"technical/instructions/#instruction-set","text":"A summary of all Blaze instructions is provided in the table below. Note Stack changes are denoted as before \u2192 after , where stack items are shown from bottom to top. Instruction parameters are shown using Greek letters (e.g., \u03b1 is the first parameter, \u03b2 the second, etc). Example of a single-parameter instruction: POP \u03b1 Example of a two-parameter instruction: EXTENDED_ARG \u03b2 LDLOCAL \u03b1 Stack notation example: ..., x, y \u2192 ..., z . This means the instruction pops y and x, and pushes z. Type Name # Params Stack Description 00 NOP 0 \u2192 No operation 01 POP 1 value \u2192 Removes \u03b1 values from the stack 02 EXTENDED_ARG 1 \u2192 Extend the previous argument with N 03 LDNULL 0 \u2192 null Load null instance onto stack 04 LDARG 1 \u2192 value Load function parameter \u03b1 onto stack 05 LDCONST 1 \u2192 value Load constant \u03b1 onto stack 06 LDLOCAL 2 \u2192 value Loads the value from the local slot \u03b1 with upvalue \u03b2 onto the stack 07 LDVAR 1 \u2192 value Load a module variable onto the stack, with \u03b1 representing the string constant which holds the name 08 LDFUNC 1 \u2192 func Loads the function \u03b1 onto the stack 09 LDCLASS 1 \u2192 class Loads the class \u03b1 onto the stack 0A LDBOOL 1 \u2192 value Loads a boolean of value \u03b1 onto the stack 0B STLOCAL 2 value \u2192 Stores the top stack value into local slot \u03b1 with upvalue \u03b2 0C STVAR 1 value \u2192 Stores the top stack value into a module variable, with \u03b1 representing the string constant which holds the name 0D STARG 1 value \u2192 Store top stack value into function parameter \u03b1 0E CALL 1 argn, ..., arg1, callable \u2192 result Calls the top stack value with number of parameters \u03b1 0F RET 0 value \u2192 Returns the top stack value 10 ADD 0 left, right \u2192 result Adds two objects 11 SUB 0 left, right \u2192 result Subtracts two objects 12 MUL 0 left, right \u2192 result Multiplies two objects 13 DIV 0 left, right \u2192 result Divides two objects 14 INTDIV 0 left, right \u2192 result Performs integer division on two objects 15 THROW 0 value \u2192 Throws an exception with top stack value 16 CATCH 1 value \u2192 Stores relative position \u03b1 of the catch block into the exception stack 17 TRY_END 0 \u2192 Indicates the exit of a try block 18 EQ 0 left, right \u2192 result Compares two objects 19 LT 0 left, right \u2192 result Less than comparison 1A LTE 0 left, right \u2192 result Less than or equals comparison 1B NOT 0 value \u2192 negated Negates an object 1C JMP 1 \u2192 Relative jump \u03b1 instructions ahead 1D JMPB 1 \u2192 Relative jump \u03b1 instructions back 1E JMPA 1 \u2192 Absolute jump to instruction \u03b1 1F JMPT 1 value \u2192 Relative jump \u03b1 instructions ahead if top stack value is true 20 JMPF 1 value \u2192 Relative jump \u03b1 instructions ahead if top stack value is false 21 OR 0 left, right \u2192 value Perform a logical OR operation on two objects 22 AND 0 left, right \u2192 value Perform a logical AND operation on two objects 23 DUP 1 value \u2192 value * \u03b1 Create \u03b1 copies of the top stack value 24 VARARGS 1 valuen, ..., value1 \u2192 / 25 LDLIST 1 valuen, ..., value1 \u2192 list Create a list from \u03b1 values from the stack 26 LDOBJ 1 valuen, keyn, ..., value1, key1 \u2192 dict Create a dictionary from \u03b1 key-value pairs from the stack 27 LDINDEX 0 idx, object \u2192 value Load the value stored at index idx from object 28 STINDEX 0 value, idx, object \u2192 Store a value at index idx in object 29 LDPROP 1 object \u2192 value Load object property \u03b1 onto stack, with \u03b1 representing the string constant which holds the name 2A STPROP 1 value, object \u2192 Store value into object property \u03b1, with \u03b1 representing the string constant which holds the name 2B LDEVENT 0 \u2192 event Create and push an event object 2C ITER 0 value \u2192 iterator Create an iterator for an object 2D NEW 1 argn, ... arg1, class \u2192 instance Creates a new instance of a class, with \u03b1 being the number of constructor parameters 2E ATTACH 0 func, event \u2192 Attaches a callback to an event","title":"Instruction Set"},{"location":"technical/internals/","text":"Module Internals Internally, the Blaze interpreter uses an instance of a Blaze Virual Machine (VM). The VM is a stack machine, meaning that instructions assume that operands will be on the stack, and results placed onto the stack. Take the following Blaze program: func main() { var x = 2 + 3; } We can compile it by using blzc -s .\\app.txt -d , where -d indicates to also store debug information (line numbers). To dump the module information, use the the -d (as in dump) flag on the interpreter: blzi -m app.blzm -d , which produces the following output: == INFORMATION == Version 1.0 Name '.\\app.txt' Debug? True == CONSTANTS == 0: String(main) 1: Number(2) 2: Number(5) == VARIABLES == 0: main (PRIVATE) == FUNCTIONS == <anonymous> (# args: 0, # locals: 0, Varargs: False, # instructions: 4) 1 LDFUNC 1 STVAR 0 0 LDNULL 0 RET 0 main (# args: 0, # locals: 1, Varargs: False, # instructions: 6) 2 LDCONST 1 LDCONST 2 ADD 0 STLOCAL 0 0 LDNULL 0 RET 0 == CLASSES == Instruction Format Each instruction consists of: An opcode (1 byte): determines the instruction type. Optional operands (1\u20134 bytes): depending on the instruction. Operands include: Constant indices : reference values in the constants table. Variable indices : used to access locals or globals. Offsets : for jumps and conditional branches. If an operand doesn't fit in one byte, EXTENDED_ARG instructions are used to increase its size. Constants Table The constants table stores all literals used in the program: numbers and strings. Each constant has an index used by the instructions. Constants can be loaded onto the stack by using the LDCONST instruction whose argument is an index into the constant table. Variables Table Each variable declared at module level is stored with its name and visibility and can be accessed using STVAR and LDVAR instructions. Note The parameter for STVAR and LDVAR is not a direct variable index. Instead, it refers to the index of a string constant that contains the name of the variable. Functions Table Each function is compiled to bytecode and stored with: Name (optional) Argument count Whether it accepts varargs Local count Instruction count Its bytecode instructions Example Walkthrough Take the main function from the bytecode dump from earlier: main (# args: 0, # locals: 1, Varargs: False, # instructions: 6) 2 LDCONST 1 LDCONST 2 ADD 0 STLOCAL 0 0 LDNULL 0 RET 0 Here's what happens: Instruction Stack Description LDCONST 1 2 Push the constant 2 (index 1) onto the stack LDCONST 2 2, 3 Push the constant 3 (index 2) onto the stack ADD 5 Pop and add both values and push the result 5 STLOCAL 0 \u2205 Pops and stores the result in the first local variable x LDNULL null Pushes null to be returned from function RET null Returns from the function Note : \u2205 denotes empty stack","title":"Module Internals"},{"location":"technical/internals/#module-internals","text":"Internally, the Blaze interpreter uses an instance of a Blaze Virual Machine (VM). The VM is a stack machine, meaning that instructions assume that operands will be on the stack, and results placed onto the stack. Take the following Blaze program: func main() { var x = 2 + 3; } We can compile it by using blzc -s .\\app.txt -d , where -d indicates to also store debug information (line numbers). To dump the module information, use the the -d (as in dump) flag on the interpreter: blzi -m app.blzm -d , which produces the following output: == INFORMATION == Version 1.0 Name '.\\app.txt' Debug? True == CONSTANTS == 0: String(main) 1: Number(2) 2: Number(5) == VARIABLES == 0: main (PRIVATE) == FUNCTIONS == <anonymous> (# args: 0, # locals: 0, Varargs: False, # instructions: 4) 1 LDFUNC 1 STVAR 0 0 LDNULL 0 RET 0 main (# args: 0, # locals: 1, Varargs: False, # instructions: 6) 2 LDCONST 1 LDCONST 2 ADD 0 STLOCAL 0 0 LDNULL 0 RET 0 == CLASSES ==","title":"Module Internals"},{"location":"technical/internals/#instruction-format","text":"Each instruction consists of: An opcode (1 byte): determines the instruction type. Optional operands (1\u20134 bytes): depending on the instruction. Operands include: Constant indices : reference values in the constants table. Variable indices : used to access locals or globals. Offsets : for jumps and conditional branches. If an operand doesn't fit in one byte, EXTENDED_ARG instructions are used to increase its size.","title":"Instruction Format"},{"location":"technical/internals/#constants-table","text":"The constants table stores all literals used in the program: numbers and strings. Each constant has an index used by the instructions. Constants can be loaded onto the stack by using the LDCONST instruction whose argument is an index into the constant table.","title":"Constants Table"},{"location":"technical/internals/#variables-table","text":"Each variable declared at module level is stored with its name and visibility and can be accessed using STVAR and LDVAR instructions. Note The parameter for STVAR and LDVAR is not a direct variable index. Instead, it refers to the index of a string constant that contains the name of the variable.","title":"Variables Table"},{"location":"technical/internals/#functions-table","text":"Each function is compiled to bytecode and stored with: Name (optional) Argument count Whether it accepts varargs Local count Instruction count Its bytecode instructions","title":"Functions Table"},{"location":"technical/internals/#example-walkthrough","text":"Take the main function from the bytecode dump from earlier: main (# args: 0, # locals: 1, Varargs: False, # instructions: 6) 2 LDCONST 1 LDCONST 2 ADD 0 STLOCAL 0 0 LDNULL 0 RET 0 Here's what happens: Instruction Stack Description LDCONST 1 2 Push the constant 2 (index 1) onto the stack LDCONST 2 2, 3 Push the constant 3 (index 2) onto the stack ADD 5 Pop and add both values and push the result 5 STLOCAL 0 \u2205 Pops and stores the result in the first local variable x LDNULL null Pushes null to be returned from function RET null Returns from the function Note : \u2205 denotes empty stack","title":"Example Walkthrough"},{"location":"technical/module/","text":"Module Format A Blaze module is a binary file that holds the intermediate representation of a Blaze program. It consists of variable, function and class data. A .blzm file consists of the following sections, in order: Header Constants Variables Functions Classes The following is the formal definition of a module file: struct module { head :: header; const_count :: uint32; constants :: constant[const_count]; var_count :: uint32; variables :: variable[var_count]; func_count :: uint32; functions :: function[func_count]; class_count :: uint32; classes :: class[class_count]; } The header holds the version of the format it uses and the name of the module. It's defined as: struct header { identifier :: uint32; v_major :: uint8; v_minor :: uint8; name_len :: uint16; name :: char[name_len]; is_debug :: bool; } Constants Constants are values that appear once or multiple times in code, such as numbers (eg. 10, 69, 420, etc.) and strings (eg. \"Hello World\"), that can be referenced by the rest of the module. The following is the definition of a constant: enum ctype :: uint8 { 0: NUMBER; 1: STRING; } struct constant { type :: ctype; if(type == ctype.NUMBER) { value :: float64; } else if(type == ctype.STRING) { len :: uint16; value :: char[len]; } } Variables Each variable in the module is defined with a name and a visibility modifier. enum vtype :: uint8 { 0: PRIVATE; 1: PUBLIC; 2: EXTERNAL; } struct variable { type :: vtype; name_ref :: uint16; // index to string constant (one-indexed) } Functions Functions include name reference, argument information, and their instruction bytecode. struct instruction { op :: opcode; arg :: uint8; } struct function { name_ref :: uint16; // index to string constant (one-indexed) num_args :: uint8; varargs :: bool; local_count :: uint8; // instruction block inst_count :: uint16; instructions :: instruction[inst_count]; } Classes Each class includes its name, member identifiers, and a reference to its constructor. struct class { name_ref :: uint16; // index to string constant (one-indexed) member_count :: uint8; members :: uint16[member_count]; // list of string constant refs (zero-indexed) constructor_ref :: uint16; // reference to function (zero-indexed) } Full Definition // Constants enum ctype :: uint8 { 0: NUMBER; 1: STRING; } struct constant { type :: ctype; if(type == ctype.NUMBER) { value :: float64; } else if(type == ctype.STRING) { len :: uint16; value :: char[len]; } } // Variables enum vtype :: uint8 { 0: PRIVATE; 1: PUBLIC; 2: EXTERNAL; } struct variable { type :: vtype; name_ref :: uint16; // index to string constant (one-indexed) } // Functions enum opcode :: uint8 { 0: NOP; 1: POP; 2: EXTENDED_ARG; 3: LDNULL; 4: LDARG; 5: LDCONST; 6: LDLOCAL; 7: LDVAR; 8: LDFUNC; 9: LDCLASS; 10: LDBOOL; 11: STLOCAL; 12: STVAR; 13: STARG; 14: CALL; 15: RET; 16: ADD; 17: SUB; 18: MUL; 19: DIV; 20: INTDIV; 21: THROW; 22: CATCH; 23: TRY_END; 24: EQ; 25: LT; 26: LTE; 27: NOT; 28: JMP; 29: JMPB; 30: JMPA; 31: JMPT; 32: JMPF; 33: OR; 34: AND; 35: DUP; 36: VARARGS; 37: LDLIST; 38: LDOBJ; 39: LDINDEX; 40: STINDEX; 41: LDPROP; 42: STPROP; 43: LDEVENT; 44: ITER; 45: NEW; 46: ATTACH; } struct instruction { op :: opcode; arg :: uint8; } struct function { name_ref :: uint16; // index to string constant (one-indexed) num_args :: uint8; varargs :: bool; local_count :: uint8; // instruction block inst_count :: uint16; instructions :: instruction[inst_count]; } // Classes struct class { name_ref :: uint16; // index to string constant (one-indexed) member_count :: uint8; members :: uint16[member_count]; // list of string constant refs (zero-indexed) constructor_ref :: uint16; // reference to function (zero-indexed) } struct header { identifier :: uint32; v_major :: uint8; v_minor :: uint8; name_len :: uint16; name :: char[name_len]; is_debug :: bool; } @entry struct module { head :: header; const_count :: uint32; constants :: constant[const_count]; var_count :: uint32; variables :: variable[var_count]; func_count :: uint32; functions :: function[func_count]; class_count :: uint32; classes :: class[class_count]; }","title":"Module Format"},{"location":"technical/module/#module-format","text":"A Blaze module is a binary file that holds the intermediate representation of a Blaze program. It consists of variable, function and class data. A .blzm file consists of the following sections, in order: Header Constants Variables Functions Classes The following is the formal definition of a module file: struct module { head :: header; const_count :: uint32; constants :: constant[const_count]; var_count :: uint32; variables :: variable[var_count]; func_count :: uint32; functions :: function[func_count]; class_count :: uint32; classes :: class[class_count]; } The header holds the version of the format it uses and the name of the module. It's defined as: struct header { identifier :: uint32; v_major :: uint8; v_minor :: uint8; name_len :: uint16; name :: char[name_len]; is_debug :: bool; }","title":"Module Format"},{"location":"technical/module/#constants","text":"Constants are values that appear once or multiple times in code, such as numbers (eg. 10, 69, 420, etc.) and strings (eg. \"Hello World\"), that can be referenced by the rest of the module. The following is the definition of a constant: enum ctype :: uint8 { 0: NUMBER; 1: STRING; } struct constant { type :: ctype; if(type == ctype.NUMBER) { value :: float64; } else if(type == ctype.STRING) { len :: uint16; value :: char[len]; } }","title":"Constants"},{"location":"technical/module/#variables","text":"Each variable in the module is defined with a name and a visibility modifier. enum vtype :: uint8 { 0: PRIVATE; 1: PUBLIC; 2: EXTERNAL; } struct variable { type :: vtype; name_ref :: uint16; // index to string constant (one-indexed) }","title":"Variables"},{"location":"technical/module/#functions","text":"Functions include name reference, argument information, and their instruction bytecode. struct instruction { op :: opcode; arg :: uint8; } struct function { name_ref :: uint16; // index to string constant (one-indexed) num_args :: uint8; varargs :: bool; local_count :: uint8; // instruction block inst_count :: uint16; instructions :: instruction[inst_count]; }","title":"Functions"},{"location":"technical/module/#classes","text":"Each class includes its name, member identifiers, and a reference to its constructor. struct class { name_ref :: uint16; // index to string constant (one-indexed) member_count :: uint8; members :: uint16[member_count]; // list of string constant refs (zero-indexed) constructor_ref :: uint16; // reference to function (zero-indexed) }","title":"Classes"},{"location":"technical/module/#full-definition","text":"// Constants enum ctype :: uint8 { 0: NUMBER; 1: STRING; } struct constant { type :: ctype; if(type == ctype.NUMBER) { value :: float64; } else if(type == ctype.STRING) { len :: uint16; value :: char[len]; } } // Variables enum vtype :: uint8 { 0: PRIVATE; 1: PUBLIC; 2: EXTERNAL; } struct variable { type :: vtype; name_ref :: uint16; // index to string constant (one-indexed) } // Functions enum opcode :: uint8 { 0: NOP; 1: POP; 2: EXTENDED_ARG; 3: LDNULL; 4: LDARG; 5: LDCONST; 6: LDLOCAL; 7: LDVAR; 8: LDFUNC; 9: LDCLASS; 10: LDBOOL; 11: STLOCAL; 12: STVAR; 13: STARG; 14: CALL; 15: RET; 16: ADD; 17: SUB; 18: MUL; 19: DIV; 20: INTDIV; 21: THROW; 22: CATCH; 23: TRY_END; 24: EQ; 25: LT; 26: LTE; 27: NOT; 28: JMP; 29: JMPB; 30: JMPA; 31: JMPT; 32: JMPF; 33: OR; 34: AND; 35: DUP; 36: VARARGS; 37: LDLIST; 38: LDOBJ; 39: LDINDEX; 40: STINDEX; 41: LDPROP; 42: STPROP; 43: LDEVENT; 44: ITER; 45: NEW; 46: ATTACH; } struct instruction { op :: opcode; arg :: uint8; } struct function { name_ref :: uint16; // index to string constant (one-indexed) num_args :: uint8; varargs :: bool; local_count :: uint8; // instruction block inst_count :: uint16; instructions :: instruction[inst_count]; } // Classes struct class { name_ref :: uint16; // index to string constant (one-indexed) member_count :: uint8; members :: uint16[member_count]; // list of string constant refs (zero-indexed) constructor_ref :: uint16; // reference to function (zero-indexed) } struct header { identifier :: uint32; v_major :: uint8; v_minor :: uint8; name_len :: uint16; name :: char[name_len]; is_debug :: bool; } @entry struct module { head :: header; const_count :: uint32; constants :: constant[const_count]; var_count :: uint32; variables :: variable[var_count]; func_count :: uint32; functions :: function[func_count]; class_count :: uint32; classes :: class[class_count]; }","title":"Full Definition"},{"location":"types/containers/","text":"Containers string Strings are immutable sequences of characters. Common operations include: Concatenation: \"Hello \" + \"world\" Indexing: \"abc\"[0] \u2192 \"a\" Length: \"abc\".length \u2192 3 See Strings for more details. list Lists are ordered and mutable. You can append, remove, or index elements: var items = [1, 2, 3]; items.append(4); console.print(items[0]); // 1 See Lists for more details. dict Dictionaries store key-value pairs. Keys are usually strings: var user = { \"name\": \"Alice\", \"age\": 30 }; console.print(user[\"name\"]); See Dictionaries for more details.","title":"Containers"},{"location":"types/containers/#containers","text":"","title":"Containers"},{"location":"types/containers/#string","text":"Strings are immutable sequences of characters. Common operations include: Concatenation: \"Hello \" + \"world\" Indexing: \"abc\"[0] \u2192 \"a\" Length: \"abc\".length \u2192 3 See Strings for more details.","title":"string"},{"location":"types/containers/#list","text":"Lists are ordered and mutable. You can append, remove, or index elements: var items = [1, 2, 3]; items.append(4); console.print(items[0]); // 1 See Lists for more details.","title":"list"},{"location":"types/containers/#dict","text":"Dictionaries store key-value pairs. Keys are usually strings: var user = { \"name\": \"Alice\", \"age\": 30 }; console.print(user[\"name\"]); See Dictionaries for more details.","title":"dict"},{"location":"types/dicts/","text":"dict Dictionaries store key-value pairs. Creating dicts var user = { \"name\": \"Alice\", \"age\": 30 }; Properties Property Description Example .length Returns the number of key-value pairs user.length \u2192 2 .keys Returns a list of keys user.keys \u2192 [\"name\", \"age\"] Methods Method Description Example get(key, default) Returns the value of key key if it exists, otherwise default user.get(\"points\", 0) \u2192 0 contains(key) Checks whether the key key exists user.contains(\"age\") \u2192 true Indexing var user = { \"name\": \"Alice\", \"age\": 30 }; var name = user[\"name\"]; user[\"age\"] = 21; Comparison var d1 = {}; var d2 = {}; d1 == d2; // false d1 == d1; // true d2 == d2; // true","title":"Dictionaries"},{"location":"types/dicts/#dict","text":"Dictionaries store key-value pairs.","title":"dict"},{"location":"types/dicts/#creating-dicts","text":"var user = { \"name\": \"Alice\", \"age\": 30 };","title":"Creating dicts"},{"location":"types/dicts/#properties","text":"Property Description Example .length Returns the number of key-value pairs user.length \u2192 2 .keys Returns a list of keys user.keys \u2192 [\"name\", \"age\"]","title":"Properties"},{"location":"types/dicts/#methods","text":"Method Description Example get(key, default) Returns the value of key key if it exists, otherwise default user.get(\"points\", 0) \u2192 0 contains(key) Checks whether the key key exists user.contains(\"age\") \u2192 true","title":"Methods"},{"location":"types/dicts/#indexing","text":"var user = { \"name\": \"Alice\", \"age\": 30 }; var name = user[\"name\"]; user[\"age\"] = 21;","title":"Indexing"},{"location":"types/dicts/#comparison","text":"var d1 = {}; var d2 = {}; d1 == d2; // false d1 == d1; // true d2 == d2; // true","title":"Comparison"},{"location":"types/iterators/","text":"iterator Iterators produce values lazily. Creating iterators // Examples: var s = \"hello\"; var it = iter s; // Creates an iterator internally for(var c : s) { // ... } Properties Property Description Example .available Returns whether the iterator has more values to produce it.available \u2192 true .next Returns the next value and advances the iterator it.next \u2192 h Comparison var l = [1, 2, 4]; var s = \"hello\"; var it1 = iter l; var it2 = iter s; it1 == it2; // false it1 == it1; // true it2 == it2; // true","title":"Iterators"},{"location":"types/iterators/#iterator","text":"Iterators produce values lazily.","title":"iterator"},{"location":"types/iterators/#creating-iterators","text":"// Examples: var s = \"hello\"; var it = iter s; // Creates an iterator internally for(var c : s) { // ... }","title":"Creating iterators"},{"location":"types/iterators/#properties","text":"Property Description Example .available Returns whether the iterator has more values to produce it.available \u2192 true .next Returns the next value and advances the iterator it.next \u2192 h","title":"Properties"},{"location":"types/iterators/#comparison","text":"var l = [1, 2, 4]; var s = \"hello\"; var it1 = iter l; var it2 = iter s; it1 == it2; // false it1 == it1; // true it2 == it2; // true","title":"Comparison"},{"location":"types/lists/","text":"list Lists are ordered and mutable. You can append, remove, or index elements. Creating lists // Examples: var l = [1, 2, \"Hello\", null]; var empty = []; Properties Property Description Example .length Returns the number of elements [1, 3, 6].length \u2192 3 Methods Method Description Example append(o) Adds an object to the list l.add(\"Hi\") \u2192 [..., \"Hi\"] pop(idx) Removes and returns the object at index idx l.pop(1) \u2192 2 contains(o) Checks whether the object o is in the list l.contains(10) \u2192 false Indexing var l = [1, 2, \"Hello\", null]; var second = l[1]; l[3] = -20; Comparison var l1 = [20, 30]; var l2 = []; l1 == l2; // false l1 == l1; // true l2 == l2; // true // Non empty list \u2192 true if(l1) { } // Empty list \u2192 false if(l2) { }","title":"Lists"},{"location":"types/lists/#list","text":"Lists are ordered and mutable. You can append, remove, or index elements.","title":"list"},{"location":"types/lists/#creating-lists","text":"// Examples: var l = [1, 2, \"Hello\", null]; var empty = [];","title":"Creating lists"},{"location":"types/lists/#properties","text":"Property Description Example .length Returns the number of elements [1, 3, 6].length \u2192 3","title":"Properties"},{"location":"types/lists/#methods","text":"Method Description Example append(o) Adds an object to the list l.add(\"Hi\") \u2192 [..., \"Hi\"] pop(idx) Removes and returns the object at index idx l.pop(1) \u2192 2 contains(o) Checks whether the object o is in the list l.contains(10) \u2192 false","title":"Methods"},{"location":"types/lists/#indexing","text":"var l = [1, 2, \"Hello\", null]; var second = l[1]; l[3] = -20;","title":"Indexing"},{"location":"types/lists/#comparison","text":"var l1 = [20, 30]; var l2 = []; l1 == l2; // false l1 == l1; // true l2 == l2; // true // Non empty list \u2192 true if(l1) { } // Empty list \u2192 false if(l2) { }","title":"Comparison"},{"location":"types/overview/","text":"Core Types Overview Blaze provides several built-in types that form the foundation of the language. This page gives a brief overview of each type, their literal syntax, mutability, and common operations. Type Example Literals Mutable? Description null null \u2014 Represents the absence of a value boolean true , false No Boolean true/false values number 42 , 3.14 , -1 No Integer and floating-point numbers string \"hello\" , \"\" No Text values (UTF-8) list [1, 2, 3] , [] Yes Ordered collection of values dict {\"key\": 10} , {} Yes Key-value mapping function func(x) { ... } \u2014 First-class functions class class C { ... } \u2014 Blueprint for objects object new C() Yes Instance of a class iterator iter [1, 2, 3] Yes Produces values one at a time Note Types like function , class , and iterator are also first-class values, meaning they can be passed to or returned from functions, stored in variables, and compared.","title":"Overview"},{"location":"types/overview/#core-types-overview","text":"Blaze provides several built-in types that form the foundation of the language. This page gives a brief overview of each type, their literal syntax, mutability, and common operations. Type Example Literals Mutable? Description null null \u2014 Represents the absence of a value boolean true , false No Boolean true/false values number 42 , 3.14 , -1 No Integer and floating-point numbers string \"hello\" , \"\" No Text values (UTF-8) list [1, 2, 3] , [] Yes Ordered collection of values dict {\"key\": 10} , {} Yes Key-value mapping function func(x) { ... } \u2014 First-class functions class class C { ... } \u2014 Blueprint for objects object new C() Yes Instance of a class iterator iter [1, 2, 3] Yes Produces values one at a time Note Types like function , class , and iterator are also first-class values, meaning they can be passed to or returned from functions, stored in variables, and compared.","title":"Core Types Overview"},{"location":"types/primitives/","text":"Primitives null The null value represents \u201cnothing\u201d or \u201cno value\u201d. var x = null; boolean Boolean values are either true or false. var is_valid = true; if (!is_valid) { // ... } number Blaze numbers support integer and floating-point values: var a = 42; var b = 3.14; Arithmetic operations: + , - , * , / , % , == , < , > .","title":"Primitives"},{"location":"types/primitives/#primitives","text":"","title":"Primitives"},{"location":"types/primitives/#null","text":"The null value represents \u201cnothing\u201d or \u201cno value\u201d. var x = null;","title":"null"},{"location":"types/primitives/#boolean","text":"Boolean values are either true or false. var is_valid = true; if (!is_valid) { // ... }","title":"boolean"},{"location":"types/primitives/#number","text":"Blaze numbers support integer and floating-point values: var a = 42; var b = 3.14; Arithmetic operations: + , - , * , / , % , == , < , > .","title":"number"},{"location":"types/strings/","text":"string Strings are immutable sequences of characters used to store text. Creating strings // Examples: var s = \"hello\"; var empty = \"\"; Properties Property Description Example .length Returns the number of elements \"abc\".length \u2192 3 Methods Method Description Example split(delim) Splits a string with a delimiter \"a,b,c\".split(\",\") \u2192 [\"a\", \"b\", \"c\"] Indexing var s = \"hello\"; var first = s[0]; // 'h' Comparison \"abc\" == \"abc\" // true \"abc\" != \"def\" // true","title":"Strings"},{"location":"types/strings/#string","text":"Strings are immutable sequences of characters used to store text.","title":"string"},{"location":"types/strings/#creating-strings","text":"// Examples: var s = \"hello\"; var empty = \"\";","title":"Creating strings"},{"location":"types/strings/#properties","text":"Property Description Example .length Returns the number of elements \"abc\".length \u2192 3","title":"Properties"},{"location":"types/strings/#methods","text":"Method Description Example split(delim) Splits a string with a delimiter \"a,b,c\".split(\",\") \u2192 [\"a\", \"b\", \"c\"]","title":"Methods"},{"location":"types/strings/#indexing","text":"var s = \"hello\"; var first = s[0]; // 'h'","title":"Indexing"},{"location":"types/strings/#comparison","text":"\"abc\" == \"abc\" // true \"abc\" != \"def\" // true","title":"Comparison"}]}