{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Blaze Blaze is an embeddable dynamic programming language. Download the latest build from GitHub and extract the zip archive. You may add Blaze to your PATH environment variable if you wish. To confirm that Blaze is installed properly, open a command prompt and try running the compiler blzc or the interpreter blzi : > blzc Usage: blzc.exe [options] Options: -s [file] Blaze source file to compile -m [name] Use a custom module name -d Compiles as a debug module -c Print the contents of a module file (source file must be blzm) > blzi Usage: blzi.exe [options] Options: -m [file] Module file to execute -d Print the contents of the module file","title":"Installation"},{"location":"#blaze","text":"Blaze is an embeddable dynamic programming language. Download the latest build from GitHub and extract the zip archive. You may add Blaze to your PATH environment variable if you wish. To confirm that Blaze is installed properly, open a command prompt and try running the compiler blzc or the interpreter blzi : > blzc Usage: blzc.exe [options] Options: -s [file] Blaze source file to compile -m [name] Use a custom module name -d Compiles as a debug module -c Print the contents of a module file (source file must be blzm) > blzi Usage: blzi.exe [options] Options: -m [file] Module file to execute -d Print the contents of the module file","title":"Blaze"},{"location":"start/classes/","text":"Classes Classes are declared using the class keyword. class Counter { var current; Counter(initial) { if(initial == null) current = 0; else current = initial; } func next() { return current++; } } Classes are also first-class values, meaning they can be assigned to variables, passed as arguments, or returned from functions. Note Inside class functions, you can use this to refer to the current instance and access its members, e.g., this.current . Instantiating To create an instance of a class, use the new keyword: func main() { var c1 = new Counter(5); var c2 = new Counter(); console.print(c1.next()); console.print(c1.next()); console.print(c2.next()); console.print(c2.next()); } Class Scope and Visibility Unlike functions and variables, all classes are module-level declarations. They can only be declared at the top scope of a Blaze source file. The following modifiers can be used with classes: public : Exposes the class to other modules private : The class is accessible only within its own module If no modifier is provided, private is assumed. Note All class members (variables and functions) are implicitly public. Blaze does not currently support member-level access modifiers.","title":"Classes"},{"location":"start/classes/#classes","text":"Classes are declared using the class keyword. class Counter { var current; Counter(initial) { if(initial == null) current = 0; else current = initial; } func next() { return current++; } } Classes are also first-class values, meaning they can be assigned to variables, passed as arguments, or returned from functions. Note Inside class functions, you can use this to refer to the current instance and access its members, e.g., this.current .","title":"Classes"},{"location":"start/classes/#instantiating","text":"To create an instance of a class, use the new keyword: func main() { var c1 = new Counter(5); var c2 = new Counter(); console.print(c1.next()); console.print(c1.next()); console.print(c2.next()); console.print(c2.next()); }","title":"Instantiating"},{"location":"start/classes/#class-scope-and-visibility","text":"Unlike functions and variables, all classes are module-level declarations. They can only be declared at the top scope of a Blaze source file. The following modifiers can be used with classes: public : Exposes the class to other modules private : The class is accessible only within its own module If no modifier is provided, private is assumed. Note All class members (variables and functions) are implicitly public. Blaze does not currently support member-level access modifiers.","title":"Class Scope and Visibility"},{"location":"start/events/","text":"Events Events are objects that allow you to attach callback functions, which are triggered when the event is invoked. Creating events Events are created using the keyword event as an expression. You can invoke an event simply by calling it like a function: export message = event; func main() { message(\"Hello World\"); } Handling events To handle an event, you can define a callback using the event keyword again, this time as a declaration. import console; import message; event message(msg) { console.print(\"Received: \", msg); } When the event message is triggered (as shown in the previous example), all callbacks registered for it will be executed with the given arguments. Filtering Parameters You can restrict when a callback is executed by specifying expected values for the parameters. This allows you to respond only to specific cases. import console; import message; event message(msg [\"hello\", \"world\"]) { console.print(\"Received special case: \", msg); } In the example above, the callback is triggered only when msg is \"hello\" or \"world\" .","title":"Events"},{"location":"start/events/#events","text":"Events are objects that allow you to attach callback functions, which are triggered when the event is invoked.","title":"Events"},{"location":"start/events/#creating-events","text":"Events are created using the keyword event as an expression. You can invoke an event simply by calling it like a function: export message = event; func main() { message(\"Hello World\"); }","title":"Creating events"},{"location":"start/events/#handling-events","text":"To handle an event, you can define a callback using the event keyword again, this time as a declaration. import console; import message; event message(msg) { console.print(\"Received: \", msg); } When the event message is triggered (as shown in the previous example), all callbacks registered for it will be executed with the given arguments.","title":"Handling events"},{"location":"start/events/#filtering-parameters","text":"You can restrict when a callback is executed by specifying expected values for the parameters. This allows you to respond only to specific cases. import console; import message; event message(msg [\"hello\", \"world\"]) { console.print(\"Received special case: \", msg); } In the example above, the callback is triggered only when msg is \"hello\" or \"world\" .","title":"Filtering Parameters"},{"location":"start/functions/","text":"Functions As we've seen in the previous sections, functions are declared using the func keyword. func my_func(arg1, arg2) { // code } Functions are first-class values in Blaze, meaning they can be assigned to variables, passed as arguments, or returned from other functions. You can also define functions as expressions (lambdas), for example: import console; func main() { var my_func = func(arg1, arg2) { console.print(\"Called with: \", arg1, \" \", arg2); }; my_func(20, \"aaa\"); } Module Functions Module-level functions are declared at the top scope of a Blaze source file. Like module variables, functions can be exposed and requested from other modules. The following modifiers can be used with module functions: public : Exposes the function to other modules private : The function is accessible only within its own module If no modifier is provided, private is assumed by default. Here's an example of a module that exposes two functions: var count = 0; public func next() { return count++; } public func current() { return count; } In another module, the exposed functions can be accessed as follows: import console; import next; import current; func main() { console.print(current()); next(); next(); console.print(current()); } Initialization Internally, module-level functions are treated as function objects stored in module variables. That means the following declaration: public func my_func() { // code } Is internally equivalent to: public var my_func; static my_func = func() { // code }; This ensures consistency with how module variables are initialized and makes the language easier to reason about.","title":"Functions"},{"location":"start/functions/#functions","text":"As we've seen in the previous sections, functions are declared using the func keyword. func my_func(arg1, arg2) { // code } Functions are first-class values in Blaze, meaning they can be assigned to variables, passed as arguments, or returned from other functions. You can also define functions as expressions (lambdas), for example: import console; func main() { var my_func = func(arg1, arg2) { console.print(\"Called with: \", arg1, \" \", arg2); }; my_func(20, \"aaa\"); }","title":"Functions"},{"location":"start/functions/#module-functions","text":"Module-level functions are declared at the top scope of a Blaze source file. Like module variables, functions can be exposed and requested from other modules. The following modifiers can be used with module functions: public : Exposes the function to other modules private : The function is accessible only within its own module If no modifier is provided, private is assumed by default. Here's an example of a module that exposes two functions: var count = 0; public func next() { return count++; } public func current() { return count; } In another module, the exposed functions can be accessed as follows: import console; import next; import current; func main() { console.print(current()); next(); next(); console.print(current()); }","title":"Module Functions"},{"location":"start/functions/#initialization","text":"Internally, module-level functions are treated as function objects stored in module variables. That means the following declaration: public func my_func() { // code } Is internally equivalent to: public var my_func; static my_func = func() { // code }; This ensures consistency with how module variables are initialized and makes the language easier to reason about.","title":"Initialization"},{"location":"start/helloworld/","text":"First program in Blaze To write a simple hello world program, create a file (eg. hw.blz ) and write the following code: extern var console; func main() { console.print(\"Hello World\"); } Now we use blzc to compile the source file to a module file: > blzc -s hw.blz Compiled to 'hw.blzm' Now that we have a module file, we can run it using blzi : > blzi -m hw.blzm Hello World This is a simple hello world program. Notice that we have to specify that the console variable is external. Blaze doesn't have a concept of a global environment like most embeddable/scripting languages do. Blaze works with modules. Each Blaze source file is compiled to a module, which contains functions, classes and variables. Variables can be declared as public, private or extern. The console interface is provided from an external library that contains a module. During runtime each module can have multiple children and a parent which make up a hierarchy.","title":"Hello World"},{"location":"start/helloworld/#first-program-in-blaze","text":"To write a simple hello world program, create a file (eg. hw.blz ) and write the following code: extern var console; func main() { console.print(\"Hello World\"); } Now we use blzc to compile the source file to a module file: > blzc -s hw.blz Compiled to 'hw.blzm' Now that we have a module file, we can run it using blzi : > blzi -m hw.blzm Hello World This is a simple hello world program. Notice that we have to specify that the console variable is external. Blaze doesn't have a concept of a global environment like most embeddable/scripting languages do. Blaze works with modules. Each Blaze source file is compiled to a module, which contains functions, classes and variables. Variables can be declared as public, private or extern. The console interface is provided from an external library that contains a module. During runtime each module can have multiple children and a parent which make up a hierarchy.","title":"First program in Blaze"},{"location":"start/variables/","text":"Variables Variables in Blaze are declared using the var keyword: import console; func main() { var name = console.input(\"What's your name? \"); console.print(\"Hello \", name, \"!\"); } Module Variables Module-level variables are declared at the top scope of a Blaze source file. These variables play an important role in Blaze's modular design. Since each Blaze source file is compiled as a module, variables can be: Exposed to other modules Requested from other modules The following modifiers can be used with module variables: public : Exposes the variable to other modules private : The variable is accessible only within its own module extern : Indicates the variable is defined in another module If no modifier is provided, private is assumed by default. var some_var = 20; public var username = \"vladimirdabic\"; extern var console; func main() { console.print(username); } Note public var and extern var can be written in a short way using the export and import aliases, respectively. var some_var = 20; export username = \"vladimirdabic\"; import console; func main() { console.print(username); } Initialization When a module is loaded, all module-level variables are initialized. This is done by what Blaze calls a static function . The static function is a special block of code that runs automatically when the module is loaded, similar to a constructor in a class. It's used to assign initial values or perform setup tasks. You can define static code using the static keyword, which can be followed by either a single statement or a block of statements: static var x = 20; static { // code } For example, the following module variable declaration: var x = 20; Is internally equivalent to: var x; static x = 20; This means module variables are declared first, and then initialized when the module is loaded.","title":"Variables"},{"location":"start/variables/#variables","text":"Variables in Blaze are declared using the var keyword: import console; func main() { var name = console.input(\"What's your name? \"); console.print(\"Hello \", name, \"!\"); }","title":"Variables"},{"location":"start/variables/#module-variables","text":"Module-level variables are declared at the top scope of a Blaze source file. These variables play an important role in Blaze's modular design. Since each Blaze source file is compiled as a module, variables can be: Exposed to other modules Requested from other modules The following modifiers can be used with module variables: public : Exposes the variable to other modules private : The variable is accessible only within its own module extern : Indicates the variable is defined in another module If no modifier is provided, private is assumed by default. var some_var = 20; public var username = \"vladimirdabic\"; extern var console; func main() { console.print(username); } Note public var and extern var can be written in a short way using the export and import aliases, respectively. var some_var = 20; export username = \"vladimirdabic\"; import console; func main() { console.print(username); }","title":"Module Variables"},{"location":"start/variables/#initialization","text":"When a module is loaded, all module-level variables are initialized. This is done by what Blaze calls a static function . The static function is a special block of code that runs automatically when the module is loaded, similar to a constructor in a class. It's used to assign initial values or perform setup tasks. You can define static code using the static keyword, which can be followed by either a single statement or a block of statements: static var x = 20; static { // code } For example, the following module variable declaration: var x = 20; Is internally equivalent to: var x; static x = 20; This means module variables are declared first, and then initialized when the module is loaded.","title":"Initialization"},{"location":"types/containers/","text":"Containers string Strings are immutable sequences of characters. Common operations include: Concatenation: \"Hello \" + \"world\" Indexing: \"abc\"[0] \u2192 \"a\" Length: \"abc\".length \u2192 3 See Strings for more details. list Lists are ordered and mutable. You can append, remove, or index elements: var items = [1, 2, 3]; items.append(4); console.print(items[0]); // 1 See Lists for more details. dict Dictionaries store key-value pairs. Keys are usually strings: var user = { \"name\": \"Alice\", \"age\": 30 }; console.print(user[\"name\"]); See Dictionaries for more details.","title":"Containers"},{"location":"types/containers/#containers","text":"","title":"Containers"},{"location":"types/containers/#string","text":"Strings are immutable sequences of characters. Common operations include: Concatenation: \"Hello \" + \"world\" Indexing: \"abc\"[0] \u2192 \"a\" Length: \"abc\".length \u2192 3 See Strings for more details.","title":"string"},{"location":"types/containers/#list","text":"Lists are ordered and mutable. You can append, remove, or index elements: var items = [1, 2, 3]; items.append(4); console.print(items[0]); // 1 See Lists for more details.","title":"list"},{"location":"types/containers/#dict","text":"Dictionaries store key-value pairs. Keys are usually strings: var user = { \"name\": \"Alice\", \"age\": 30 }; console.print(user[\"name\"]); See Dictionaries for more details.","title":"dict"},{"location":"types/dicts/","text":"dict Dictionaries store key-value pairs. Creating dicts var user = { \"name\": \"Alice\", \"age\": 30 }; Properties Property Description Example .length Returns the number of key-value pairs user.length \u2192 2 .keys Returns a list of keys user.keys \u2192 [\"name\", \"age\"] Methods Method Description Example get(key, default) Returns the value of key key if it exists, otherwise default user.get(\"points\", 0) \u2192 0 contains(key) Checks whether the key key exists user.contains(\"age\") \u2192 true Indexing var user = { \"name\": \"Alice\", \"age\": 30 }; var name = user[\"name\"]; user[\"age\"] = 21; Comparison var d1 = {}; var d2 = {}; d1 == d2; // false d1 == d1; // true d2 == d2; // true","title":"Dictionaries"},{"location":"types/dicts/#dict","text":"Dictionaries store key-value pairs.","title":"dict"},{"location":"types/dicts/#creating-dicts","text":"var user = { \"name\": \"Alice\", \"age\": 30 };","title":"Creating dicts"},{"location":"types/dicts/#properties","text":"Property Description Example .length Returns the number of key-value pairs user.length \u2192 2 .keys Returns a list of keys user.keys \u2192 [\"name\", \"age\"]","title":"Properties"},{"location":"types/dicts/#methods","text":"Method Description Example get(key, default) Returns the value of key key if it exists, otherwise default user.get(\"points\", 0) \u2192 0 contains(key) Checks whether the key key exists user.contains(\"age\") \u2192 true","title":"Methods"},{"location":"types/dicts/#indexing","text":"var user = { \"name\": \"Alice\", \"age\": 30 }; var name = user[\"name\"]; user[\"age\"] = 21;","title":"Indexing"},{"location":"types/dicts/#comparison","text":"var d1 = {}; var d2 = {}; d1 == d2; // false d1 == d1; // true d2 == d2; // true","title":"Comparison"},{"location":"types/iterators/","text":"iterator Iterators produce values lazily. Creating iterators // Examples: var s = \"hello\"; var it = iter s; // Creates an iterator internally for(var c : s) { // ... } Properties Property Description Example .available Returns whether the iterator has more values to produce it.available \u2192 true .next Returns the next value and advances the iterator it.next \u2192 h Comparison var l = [1, 2, 4]; var s = \"hello\"; var it1 = iter l; var it2 = iter s; it1 == it2; // false it1 == it1; // true it2 == it2; // true","title":"Iterators"},{"location":"types/iterators/#iterator","text":"Iterators produce values lazily.","title":"iterator"},{"location":"types/iterators/#creating-iterators","text":"// Examples: var s = \"hello\"; var it = iter s; // Creates an iterator internally for(var c : s) { // ... }","title":"Creating iterators"},{"location":"types/iterators/#properties","text":"Property Description Example .available Returns whether the iterator has more values to produce it.available \u2192 true .next Returns the next value and advances the iterator it.next \u2192 h","title":"Properties"},{"location":"types/iterators/#comparison","text":"var l = [1, 2, 4]; var s = \"hello\"; var it1 = iter l; var it2 = iter s; it1 == it2; // false it1 == it1; // true it2 == it2; // true","title":"Comparison"},{"location":"types/lists/","text":"list Lists are ordered and mutable. You can append, remove, or index elements. Creating lists // Examples: var l = [1, 2, \"Hello\", null]; var empty = []; Properties Property Description Example .length Returns the number of elements [1, 3, 6].length \u2192 3 Methods Method Description Example append(o) Adds an object to the list l.add(\"Hi\") \u2192 [..., \"Hi\"] pop(idx) Removes and returns the object at index idx l.pop(1) \u2192 2 contains(o) Checks whether the object o is in the list l.contains(10) \u2192 false Indexing var l = [1, 2, \"Hello\", null]; var second = l[1]; l[3] = -20; Comparison var l1 = [20, 30]; var l2 = []; l1 == l2; // false l1 == l1; // true l2 == l2; // true // Non empty list \u2192 true if(l1) { } // Empty list \u2192 false if(l2) { }","title":"Lists"},{"location":"types/lists/#list","text":"Lists are ordered and mutable. You can append, remove, or index elements.","title":"list"},{"location":"types/lists/#creating-lists","text":"// Examples: var l = [1, 2, \"Hello\", null]; var empty = [];","title":"Creating lists"},{"location":"types/lists/#properties","text":"Property Description Example .length Returns the number of elements [1, 3, 6].length \u2192 3","title":"Properties"},{"location":"types/lists/#methods","text":"Method Description Example append(o) Adds an object to the list l.add(\"Hi\") \u2192 [..., \"Hi\"] pop(idx) Removes and returns the object at index idx l.pop(1) \u2192 2 contains(o) Checks whether the object o is in the list l.contains(10) \u2192 false","title":"Methods"},{"location":"types/lists/#indexing","text":"var l = [1, 2, \"Hello\", null]; var second = l[1]; l[3] = -20;","title":"Indexing"},{"location":"types/lists/#comparison","text":"var l1 = [20, 30]; var l2 = []; l1 == l2; // false l1 == l1; // true l2 == l2; // true // Non empty list \u2192 true if(l1) { } // Empty list \u2192 false if(l2) { }","title":"Comparison"},{"location":"types/overview/","text":"Core Types Overview Blaze provides several built-in types that form the foundation of the language. This page gives a brief overview of each type, their literal syntax, mutability, and common operations. Type Example Literals Mutable? Description null null \u2014 Represents the absence of a value boolean true , false No Boolean true/false values number 42 , 3.14 , -1 No Integer and floating-point numbers string \"hello\" , \"\" No Text values (UTF-8) list [1, 2, 3] , [] Yes Ordered collection of values dict {\"key\": 10} , {} Yes Key-value mapping function func(x) { ... } \u2014 First-class functions class class C { ... } \u2014 Blueprint for objects object new C() Yes Instance of a class iterator iter [1, 2, 3] Yes Produces values one at a time Note Types like function , class , and iterator are also first-class values, meaning they can be passed to or returned from functions, stored in variables, and compared.","title":"Overview"},{"location":"types/overview/#core-types-overview","text":"Blaze provides several built-in types that form the foundation of the language. This page gives a brief overview of each type, their literal syntax, mutability, and common operations. Type Example Literals Mutable? Description null null \u2014 Represents the absence of a value boolean true , false No Boolean true/false values number 42 , 3.14 , -1 No Integer and floating-point numbers string \"hello\" , \"\" No Text values (UTF-8) list [1, 2, 3] , [] Yes Ordered collection of values dict {\"key\": 10} , {} Yes Key-value mapping function func(x) { ... } \u2014 First-class functions class class C { ... } \u2014 Blueprint for objects object new C() Yes Instance of a class iterator iter [1, 2, 3] Yes Produces values one at a time Note Types like function , class , and iterator are also first-class values, meaning they can be passed to or returned from functions, stored in variables, and compared.","title":"Core Types Overview"},{"location":"types/primitives/","text":"Primitives null The null value represents \u201cnothing\u201d or \u201cno value\u201d. var x = null; boolean Boolean values are either true or false. var is_valid = true; if (!is_valid) { // ... } number Blaze numbers support integer and floating-point values: var a = 42; var b = 3.14; Arithmetic operations: + , - , * , / , % , == , < , > .","title":"Primitives"},{"location":"types/primitives/#primitives","text":"","title":"Primitives"},{"location":"types/primitives/#null","text":"The null value represents \u201cnothing\u201d or \u201cno value\u201d. var x = null;","title":"null"},{"location":"types/primitives/#boolean","text":"Boolean values are either true or false. var is_valid = true; if (!is_valid) { // ... }","title":"boolean"},{"location":"types/primitives/#number","text":"Blaze numbers support integer and floating-point values: var a = 42; var b = 3.14; Arithmetic operations: + , - , * , / , % , == , < , > .","title":"number"},{"location":"types/strings/","text":"string Strings are immutable sequences of characters used to store text. Creating strings // Examples: var s = \"hello\"; var empty = \"\"; Properties Property Description Example .length Returns the number of elements \"abc\".length \u2192 3 Methods Method Description Example split(delim) Splits a string with a delimiter \"a,b,c\".split(\",\") \u2192 [\"a\", \"b\", \"c\"] Indexing var s = \"hello\"; var first = s[0]; // 'h' Comparison \"abc\" == \"abc\" // true \"abc\" != \"def\" // true","title":"Strings"},{"location":"types/strings/#string","text":"Strings are immutable sequences of characters used to store text.","title":"string"},{"location":"types/strings/#creating-strings","text":"// Examples: var s = \"hello\"; var empty = \"\";","title":"Creating strings"},{"location":"types/strings/#properties","text":"Property Description Example .length Returns the number of elements \"abc\".length \u2192 3","title":"Properties"},{"location":"types/strings/#methods","text":"Method Description Example split(delim) Splits a string with a delimiter \"a,b,c\".split(\",\") \u2192 [\"a\", \"b\", \"c\"]","title":"Methods"},{"location":"types/strings/#indexing","text":"var s = \"hello\"; var first = s[0]; // 'h'","title":"Indexing"},{"location":"types/strings/#comparison","text":"\"abc\" == \"abc\" // true \"abc\" != \"def\" // true","title":"Comparison"}]}